name: Deploy OPSAPI via Docker Compose (Self-Hosted)

# This workflow deploys OPSAPI to self-hosted runners using Docker Compose
# It uses the run-development.sh script to ensure consistency with local deployments
#
# TRIGGERS:
# - Automatically on push to main branch (deploys to 'remote' environment)
# - Manually via workflow_dispatch with custom options
#
# REQUIREMENTS:
# - Self-hosted runner with Docker and Docker Compose installed
# - Runner must have access to the target environment
# - .env file should be pre-configured on the runner at /home/bwalia/.secrets/opsapi/.env
# - SLACK_WEBHOOK secret configured for notifications

on:
  # Auto-trigger on push to main branch
  push:
    branches:
      - main
    paths-ignore:
      - "**.md"
      - "docs/**"
      - ".gitignore"

  # Manual trigger with options
  workflow_dispatch:
    inputs:
      TARGET_ENV:
        type: choice
        description: "Target environment"
        default: "remote"
        required: true
        options:
          - local
          - dev
          - test
          - acc
          - prod
          - remote

      CUSTOM_ENV:
        type: string
        description: "Custom environment name (overrides TARGET_ENV if provided)"
        required: false

      PROTOCOL:
        type: choice
        description: "API protocol"
        default: "https"
        required: true
        options:
          - https
          - http

      RESET_DB:
        type: boolean
        description: "Reset database (removes volumes - USE WITH CAUTION)"
        default: false
        required: false

      RUN_MIGRATIONS:
        type: boolean
        description: "Run database migrations after deployment"
        default: true
        required: false

      RUNNER_LABEL:
        type: string
        description: "Self-hosted runner label (default: self-hosted)"
        default: "self-hosted"
        required: false

env:
  BASE_DOMAIN: "wslcrm.com"
  SERVER_ENV_PATH: "/home/bwalia/.secrets/opsapi/.env"

jobs:
  deploy:
    name: Deploy to ${{ github.event.inputs.CUSTOM_ENV || github.event.inputs.TARGET_ENV || 'remote' }}
    runs-on: ${{ github.event.inputs.RUNNER_LABEL || 'self-hosted' }}

    steps:
      - name: Clean up Docker-owned files
        run: |
          echo "Cleaning up Docker-owned files from previous runs..."
          # Stop any running containers first
          cd ${{ github.workspace }}/lapis 2>/dev/null && docker compose down 2>/dev/null || true

          # Remove Docker-owned directories that cause permission issues
          sudo rm -rf ${{ github.workspace }}/lapis/session-data 2>/dev/null || true
          sudo rm -rf ${{ github.workspace }}/lapis/pgdata 2>/dev/null || true
          sudo rm -rf ${{ github.workspace }}/lapis/logs 2>/dev/null || true
          sudo rm -rf ${{ github.workspace }}/lapis/keycloak_data 2>/dev/null || true

          # Prune Docker build cache to fix snapshot errors
          docker builder prune -f 2>/dev/null || true

          echo "Cleanup completed"
        shell: bash
        continue-on-error: true

      - name: Set environment variables
        id: env-setup
        run: |
          # Determine trigger type and set defaults
          if [ "${{ github.event_name }}" == "push" ]; then
            echo "Triggered by push to main branch"
            TARGET_ENV="remote"
            PROTOCOL="https"
            RESET_DB="false"
          else
            echo "Triggered manually via workflow_dispatch"
            # Determine target environment
            if [ -n "${{ github.event.inputs.CUSTOM_ENV }}" ]; then
              TARGET_ENV="${{ github.event.inputs.CUSTOM_ENV }}"
              echo "Using custom environment: $TARGET_ENV"
            elif [ -n "${{ github.event.inputs.TARGET_ENV }}" ]; then
              TARGET_ENV="${{ github.event.inputs.TARGET_ENV }}"
              echo "Using preset environment: $TARGET_ENV"
            else
              TARGET_ENV="remote"
              echo "Using default environment: $TARGET_ENV"
            fi
            PROTOCOL="${{ github.event.inputs.PROTOCOL || 'https' }}"
            RESET_DB="${{ github.event.inputs.RESET_DB || 'false' }}"
          fi

          BASE_DOMAIN="${{ env.BASE_DOMAIN }}"

          # Generate API URL based on environment and protocol
          case "$TARGET_ENV" in
            local)
              API_URL="${PROTOCOL}://localhost:4010"
              ;;
            prod)
              API_URL="${PROTOCOL}://api.${BASE_DOMAIN}"
              ;;
            *)
              API_URL="${PROTOCOL}://${TARGET_ENV}-api.${BASE_DOMAIN}"
              ;;
          esac

          echo "TARGET_ENV=$TARGET_ENV" >> $GITHUB_OUTPUT
          echo "API_URL=$API_URL" >> $GITHUB_OUTPUT
          echo "PROTOCOL=$PROTOCOL" >> $GITHUB_OUTPUT
          echo "RESET_DB=$RESET_DB" >> $GITHUB_OUTPUT
          echo "TRIGGER=${{ github.event_name }}" >> $GITHUB_OUTPUT

          echo "=========================================="
          echo "Deployment Configuration:"
          echo "  Trigger: ${{ github.event_name }}"
          echo "  Environment: $TARGET_ENV"
          echo "  Protocol: $PROTOCOL"
          echo "  API URL: $API_URL"
          echo "  Reset DB: $RESET_DB"
          echo "=========================================="
        shell: bash

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Copy .env file from server secrets
        run: |
          echo "Copying .env file from server secrets path..."

          SERVER_ENV="${{ env.SERVER_ENV_PATH }}"
          TARGET_ENV_FILE="lapis/.env"

          # Check if server .env file exists
          if [ -f "$SERVER_ENV" ]; then
            echo "Found .env file at $SERVER_ENV"
            cp "$SERVER_ENV" "$TARGET_ENV_FILE"
            echo ".env file copied successfully to $TARGET_ENV_FILE"
          else
            echo "Error: .env file not found at $SERVER_ENV"
            echo "Please ensure the .env file exists on the runner at: $SERVER_ENV"
            exit 1
          fi
        shell: bash

      - name: Make run-development.sh executable
        run: chmod +x ./run-development.sh
        shell: bash

      - name: Deploy using run-development.sh
        run: |
          echo "Running deployment using run-development.sh..."

          # Build the command arguments
          ARGS="-e ${{ steps.env-setup.outputs.TARGET_ENV }}"
          ARGS="$ARGS -P ${{ steps.env-setup.outputs.PROTOCOL }}"
          ARGS="$ARGS -n"  # No git operations (already checked out)
          ARGS="$ARGS -C"  # CI mode: uses override file (no dev volume mounts, different ports)

          # Add reset-db flag if requested
          if [ "${{ steps.env-setup.outputs.RESET_DB }}" == "true" ]; then
            ARGS="$ARGS -r"
          fi

          echo "Executing: ./run-development.sh $ARGS"
          ./run-development.sh $ARGS
        shell: bash

      - name: Verify deployment
        run: |
          echo "Verifying deployment..."

          # Check if containers are running
          cd lapis
          docker compose ps

          # Health check - try to reach the API
          echo ""
          echo "Performing health check..."

          HEALTH_URL="http://localhost:4010/health"

          # Retry health check up to 5 times
          for i in {1..5}; do
            if curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL" | grep -q "200"; then
              echo "Health check passed!"
              break
            fi
            echo "Health check attempt $i failed, retrying in 5 seconds..."
            sleep 5
          done

          echo ""
          echo "=========================================="
          echo "Deployment Summary"
          echo "=========================================="
          echo "Trigger: ${{ steps.env-setup.outputs.TRIGGER }}"
          echo "Environment: ${{ steps.env-setup.outputs.TARGET_ENV }}"
          echo "API URL: ${{ steps.env-setup.outputs.API_URL }}"
          echo "Protocol: ${{ steps.env-setup.outputs.PROTOCOL }}"
          echo "Reset DB: ${{ steps.env-setup.outputs.RESET_DB }}"
          echo "=========================================="
        shell: bash

      - name: Show container logs on failure
        if: failure()
        run: |
          echo "Deployment failed. Showing container logs..."
          cd lapis
          docker compose logs --tail=100
        shell: bash

      - name: Slack notification - Success
        if: success()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_CHANNEL: github-updates
          SLACK_COLOR: ${{ job.status }}
          SLACK_ICON: https://github.com/rtCamp.png?size=48
          SLACK_MESSAGE: "OPSAPI deployed successfully to ${{ steps.env-setup.outputs.TARGET_ENV }} environment :rocket:\nAPI URL: ${{ steps.env-setup.outputs.API_URL }}\nTriggered by: ${{ steps.env-setup.outputs.TRIGGER }}\nCommit: ${{ github.sha }}"
          SLACK_TITLE: OPSAPI Deployment Success
          SLACK_USERNAME: rtCamp
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}

      - name: Slack notification - Failure
        if: failure()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_CHANNEL: github-updates
          SLACK_COLOR: ${{ job.status }}
          SLACK_ICON: https://github.com/rtCamp.png?size=48
          SLACK_MESSAGE: "OPSAPI deployment FAILED for ${{ steps.env-setup.outputs.TARGET_ENV }} environment :x:\nTriggered by: ${{ steps.env-setup.outputs.TRIGGER }}\nCommit: ${{ github.sha }}\nCheck workflow logs for details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          SLACK_TITLE: OPSAPI Deployment Failed
          SLACK_USERNAME: rtCamp
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}

  # Optional: Run post-deployment tests
  post-deploy-verification:
    name: Post-deployment verification
    runs-on: ${{ github.event.inputs.RUNNER_LABEL || 'self-hosted' }}
    needs: deploy
    if: success()

    steps:
      - name: Wait for services to stabilize
        run: |
          echo "Waiting for services to stabilize..."
          sleep 10
        shell: bash

      - name: Verify API endpoints
        run: |
          echo "Verifying API endpoints..."

          # Test health endpoint
          HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:4010/health")
          if [ "$HEALTH_RESPONSE" == "200" ]; then
            echo "✓ Health endpoint: OK (HTTP $HEALTH_RESPONSE)"
          else
            echo "✗ Health endpoint: FAILED (HTTP $HEALTH_RESPONSE)"
            exit 1
          fi

          # Test root endpoint
          ROOT_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:4010/")
          if [ "$ROOT_RESPONSE" == "200" ]; then
            echo "✓ Root endpoint: OK (HTTP $ROOT_RESPONSE)"
          else
            echo "✗ Root endpoint: FAILED (HTTP $ROOT_RESPONSE)"
            exit 1
          fi

          echo ""
          echo "All endpoint verifications passed!"
        shell: bash

      - name: Slack notification - Verification Success
        if: success()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_CHANNEL: github-updates
          SLACK_COLOR: ${{ job.status }}
          SLACK_ICON: https://github.com/rtCamp.png?size=48
          SLACK_MESSAGE: "OPSAPI post-deployment verification completed successfully :white_check_mark:\nAll API endpoints responding correctly."
          SLACK_TITLE: OPSAPI Verification Passed
          SLACK_USERNAME: rtCamp
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}

      - name: Slack notification - Verification Failed
        if: failure()
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_CHANNEL: github-updates
          SLACK_COLOR: ${{ job.status }}
          SLACK_ICON: https://github.com/rtCamp.png?size=48
          SLACK_MESSAGE: "OPSAPI post-deployment verification FAILED :warning:\nAPI endpoints may not be responding correctly.\nCheck workflow logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          SLACK_TITLE: OPSAPI Verification Failed
          SLACK_USERNAME: rtCamp
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
