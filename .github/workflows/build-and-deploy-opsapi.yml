name: Build/Push Docker Image and Deploy to K3S

on:
  push:
    branches:
      - main

  workflow_dispatch:
    inputs:
      TARGET_ENV:
        type: choice
        description: "Please choose the Target environment"
        default: "test"
        required: true
        options:
          - dev
          - int
          - test
          - acc
          - prod

      DEPLOYMENT_TYPE:
        type: choice
        description: "Please select the build only, deploy only or build and deploy"
        default: "deploy"
        required: true
        options:
          - build
          - deploy
          - build-and-deploy          
      PROJECT_NAME:
        type: choice
        description: "Please select the project name"
        default: "opsapi"
        required: true
        options:
          - opsapi
          - opsapi-kisaan

env:
  PROJECT_NAME: ${{ github.event.inputs.PROJECT_NAME || 'opsapi' }}
  IMAGE_REGISTRY: bwalia
  TARGET_STACK: openresty_lua
  IMAGE_NAME: opsapi
  TARGET_IMAGE_TAG: latest
  TARGET_ENV: ${{ github.event.inputs.TARGET_ENV || 'test' }}
  DEPLOYMENT_TYPE: ${{ github.event.inputs.DEPLOYMENT_TYPE || 'deploy' }}
  NODE_IMAGE_NAME: opsapi-node

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout OPSAPI code
        if: ${{ env.DEPLOYMENT_TYPE == 'build' || env.DEPLOYMENT_TYPE == 'build-and-deploy' }}
        uses: actions/checkout@v3

      - name: Build OPSAPI Docker image based on the TARGET PLATFORM Image and push to Docker Hub
        if: ${{ env.DEPLOYMENT_TYPE == 'build' || env.DEPLOYMENT_TYPE == 'build-and-deploy' }}
        run: |
          echo "OPSAPI Docker image builder!"
          echo "Build, tag, and push image to the given Docker Registry."
          docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_PASSWD }}
          # docker build -f lapis/Dockerfile --build-arg TAG=latest -t test-${{ env.TARGET_STACK }} . --no-cache
          cd lapis/
          mv nginx-kubernetes.conf nginx.conf
          docker build -f Dockerfile --build-arg TAG=latest -t test-${{ env.TARGET_STACK }} . --no-cache
          docker tag test-${{ env.TARGET_STACK }} ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TARGET_IMAGE_TAG }}
          docker push ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TARGET_IMAGE_TAG }}
        shell: bash

      - name: Build OPSAPI-NODE Helper Docker image and push to Docker Hub
        if: ${{ env.DEPLOYMENT_TYPE == 'not_disabled' }}
        run: |
          echo "Building Node.js app Docker image..."
          docker build -f node/opsapi-node/Dockerfile -t ${{ env.IMAGE_REGISTRY }}/${{ env.NODE_IMAGE_NAME }}:${{ env.TARGET_IMAGE_TAG }} .
          docker push ${{ env.IMAGE_REGISTRY }}/${{ env.NODE_IMAGE_NAME }}:${{ env.TARGET_IMAGE_TAG }}
        shell: bash
      - name: Run OpenResty Docker container
        if: ${{ env.DEPLOYMENT_TYPE == 'build' || env.DEPLOYMENT_TYPE == 'build-and-deploy' }}
        run: |
              docker run -d -p 80:80 bwalia/opsapi:latest openresty -g "daemon off;"
        shell: bash

      - name: Verify OpenResty is running
        if: ${{ env.DEPLOYMENT_TYPE == 'build' || env.DEPLOYMENT_TYPE == 'build-and-deploy' }}
        run: |
              sleep 10 # Give 10s for OpenResty to start
              curl -I http://localhost:80
        shell: bash
  deploy:
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Decode and Export Kubeconfig
        if: ${{ env.DEPLOYMENT_TYPE == 'deploy' || env.DEPLOYMENT_TYPE == 'build-and-deploy' }}
        env:
          KUBECONFIG_BASE64: ${{ secrets.KUBE_CONFIG_DATA_K3S }}
        run: |
          echo "$KUBECONFIG_BASE64" | base64 -d > kubeconfig
          export KUBECONFIG=$(pwd)/kubeconfig
          echo "Kubeconfig decoded and exported successfully."
        shell: bash

      - name: Kubeseal encrypt the env secrets file
        if: ${{ env.DEPLOYMENT_TYPE == 'deploy' || env.DEPLOYMENT_TYPE == 'build-and-deploy' }}
        run: |
            export KUBECONFIG=$(pwd)/kubeconfig
            if [ "${{ env.TARGET_ENV }}" == "dev" ]; then
                ./devops/kubeseal/kubeseal_automation.sh ${{ secrets.DOT_OPSAPI_ENV_CREDS_DEV }} "dev" ${{ env.PROJECT_NAME }}
            elif [ "${{ env.TARGET_ENV }}" == "test" ]; then
                ./devops/kubeseal/kubeseal_automation.sh ${{ secrets.DOT_OPSAPI_ENV_CREDS_TEST }} "test" ${{ env.PROJECT_NAME }}
            elif [ "${{ env.TARGET_ENV }}" == "acc" ]; then
                ./devops/kubeseal/kubeseal_automation.sh ${{ secrets.DOT_OPSAPI_ENV_CREDS_ACC }} "acc" ${{ env.PROJECT_NAME }}
            elif [ "${{ env.TARGET_ENV }}" == "prod" ]; then
                ./devops/kubeseal/kubeseal_automation.sh ${{ secrets.DOT_OPSAPI_ENV_CREDS_PROD }} "prod" ${{ env.PROJECT_NAME }}
            else
                ./devops/kubeseal/kubeseal_automation.sh ${{ secrets.DOT_OPSAPI_ENV_CREDS_INT }} "int" ${{ env.PROJECT_NAME }}
            fi
        shell: bash

      - name: Check and Install kubectl
        if: ${{ env.DEPLOYMENT_TYPE == 'deploy' || env.DEPLOYMENT_TYPE == 'build-and-deploy' }}
        run: |
          if ! command -v kubectl &> /dev/null; then
            echo "kubectl not found. Installing kubectl..."
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
          else
            echo "kubectl is already installed."
          fi
        shell: bash

      - name: Check and Install Helm
        if: ${{ env.DEPLOYMENT_TYPE == 'deploy' || env.DEPLOYMENT_TYPE == 'build-and-deploy' }}
        run: |
          if ! command -v helm &> /dev/null; then
            echo "Helm not found. Installing Helm..."
            curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
          else
            echo "Helm is already installed."
          fi
        shell: bash
      - name: Deploy Helm Chart ${{ env.PROJECT_NAME }} app
        if: ${{ env.DEPLOYMENT_TYPE == 'deploy' || env.DEPLOYMENT_TYPE == 'build-and-deploy' }}
        run: |
          export KUBECONFIG=$(pwd)/kubeconfig
          echo "Deploying Helm chart - ${{ env.PROJECT_NAME }} ${{ env.TARGET_ENV }} environment..."
          echo "Helm deleting existing release if it exists..."
          helm delete ${{ env.PROJECT_NAME }} --namespace ${{ env.TARGET_ENV }} || true
          echo "Helm upgrading or installing the release..."
          helm list -n ${{ env.PROJECT_NAME }} | grep -q "${{ env.PROJECT_NAME }}" && helm delete ${{ env.PROJECT_NAME }} -n ${{ env.TARGET_ENV }} || echo "Release ${{ env.PROJECT_NAME }} not found in namespace ${{ env.TARGET_ENV }}, skipping deletion"
          helm upgrade --install ${{ env.PROJECT_NAME }} ./devops/helm-charts/opsapi \
            -f ./devops/helm-charts/opsapi/values-${{ env.PROJECT_NAME }}-${{ env.TARGET_ENV }}.yaml \
            --set image.repository=bwalia/opsapi \
            --set image.tag=latest \
            --namespace ${{ env.TARGET_ENV }} --create-namespace
        shell: bash

      - name: Kubeseal encrypt the env secrets file for node Helper app [Deactivated for now]
        if: ${{ env.DEPLOYMENT_TYPE == 'not_disabled' }}
        run: |
            export KUBECONFIG=$(pwd)/kubeconfig
            if [ "${{ env.TARGET_ENV }}" == "dev" ]; then
                ./devops/kubeseal/kubeseal_automation_node.sh ${{ secrets.DOT_OPSAPI_NODE_ENV_CREDS_DEV }} "dev"
            elif [ "${{ env.TARGET_ENV }}" == "test" ]; then
                ./devops/kubeseal/kubeseal_automation_node.sh ${{ secrets.DOT_OPSAPI_NODE_ENV_CREDS_TEST }} "test"
            elif [ "${{ env.TARGET_ENV }}" == "acc" ]; then
                ./devops/kubeseal/kubeseal_automation_node.sh ${{ secrets.DOT_OPSAPI_NODE_ENV_CREDS_ACC }} "acc"
            elif [ "${{ env.TARGET_ENV }}" == "prod" ]; then
                ./devops/kubeseal/kubeseal_automation_node.sh ${{ secrets.DOT_OPSAPI_NODE_ENV_CREDS_PROD }} "prod"
            else
                ./devops/kubeseal/kubeseal_automation_node.sh ${{ secrets.DOT_OPSAPI_NODE_ENV_CREDS_INT }} "int"
            fi
        shell: bash            

      - name: Deploy Helm Chart for OPSAPI-NODE Helper app [Deactivated for now]
        if: ${{ env.DEPLOYMENT_TYPE == 'not_disabled' }}
        run: |
          export KUBECONFIG=$(pwd)/kubeconfig
          echo "Deploying Helm chart for Node.js app to ${{ env.TARGET_ENV }}..."
          # helm delete ${{ env.NODE_IMAGE_NAME }} --namespace ${{ env.TARGET_ENV }} || true
          helm list -n ${{ env.TARGET_ENV }} | grep -q "${{ env.NODE_IMAGE_NAME }}" && helm delete ${{ env.NODE_IMAGE_NAME }} -n ${{ env.TARGET_ENV }} || echo "Release ${{ env.NODE_IMAGE_NAME }} not found in namespace ${{ env.TARGET_ENV }}, skipping deletion"
          helm upgrade --install ${{ env.NODE_IMAGE_NAME }} ./devops/helm-charts/opsapi-node \
            -f ./devops/helm-charts/opsapi-node/values-${{ env.TARGET_ENV }}.yaml \
            --set image.repository=${{ env.IMAGE_REGISTRY }}/${{ env.NODE_IMAGE_NAME }} \
            --set image.tag=${{ env.TARGET_IMAGE_TAG }} \
            --namespace ${{ env.TARGET_ENV }} --create-namespace
        shell: bash

      - name: Slack Notification for OPSAPI ${{ env.PROJECT_NAME }} release
        if: ${{ env.DEPLOYMENT_TYPE == 'build' || env.DEPLOYMENT_TYPE == 'build-and-deploy' }}
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_CHANNEL: general
          SLACK_COLOR: ${{ job.status }}
          SLACK_ICON: https://github.com/rtCamp.png?size=48
          SLACK_MESSAGE: "${{ env.PROJECT_NAME }} deployed to https://${{ env.TARGET_ENV }}.opsapi.io/ (${{ env.TARGET_ENV }}) env :rocket:"
          SLACK_TITLE: "${{ env.PROJECT_NAME }} deployment status"
          SLACK_USERNAME: rtCamp
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
