env KEYCLOAK_AUTH_URL;
env KEYCLOAK_TOKEN_URL;
env KEYCLOAK_USERINFO_URL;
env KEYCLOAK_CLIENT_ID;
env KEYCLOAK_CLIENT_SECRET;
env KEYCLOAK_REDIRECT_URI;
env DB_HOST;
env DB_USER;
env DB_PASSWORD;
env DATABASE;
env OPENSSL_SECRET_KEY;
env OPENSSL_SECRET_IV;
env JWT_SECRET_KEY;
env LAPIS_CONFIG;
env MINIO_ENDPOINT;
env MINIO_ACCESS_KEY;
env MINIO_SECRET_KEY;
env MINIO_BUCKET;
env MINIO_REGION;
env NODE_API_URL;
env GOOGLE_CLIENT_ID;
env GOOGLE_CLIENT_SECRET;
env GOOGLE_REDIRECT_URI;
env STRIPE_SECRET_KEY;
env STRIPE_PUBLISHABLE_KEY;
env STRIPE_WEBHOOK_SECRET;
env DNS_RESOLVER;
env REDIS_HOST;
env HOSTNAME;
env APP_NAME;
env LUA_DEBUG;
env VERSION;
env STACK;
env VITE_DEPLOYMENT_TIME;
env NGINX_CONFIG_DIR;
env JWT_SECURITY_PASSPHRASE;
env API_URL;
env PRIMARY_DNS_RESOLVER;
env SECONDARY_DNS_RESOLVER;
env DNS_RESOLVER_PORT;
env FRONT_URL;
env AWS_ACCESS_KEY_ID;
env AWS_SECRET_ACCESS_KEY;
env AWS_REGION;
env CORS_ORIGIN;
env OPSAPI_CUSTOM_ROUTES_DIR;
env OPSAPI_CUSTOM_MIGRATIONS_DIR;

worker_processes ${{NUM_WORKERS}};
error_log stderr notice;
daemon off;
pid logs/nginx.pid;

events {
    worker_connections 1024;
    multi_accept on;
   use epoll;
}

http {

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for" "$host" "$request_id" $msec $request_time '
                    '$upstream_connect_time $upstream_header_time $upstream_response_time $ssl_protocol $ssl_cipher';

    access_log  /var/log/nginx/access.log  main;
    error_log  /var/log/nginx/error.log debug;

    server_tokens off;
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    lua_package_path "/app/?.lua;/usr/local/openresty/lualib/?.lua;/opt/nginx-lua-prometheus/?.lua;/opt/nginx-lua-prometheus/lib/?.lua;/opt/lua-resty-jwt/lib/?.lua;/opt/lua-resty-session/lib/?.lua;;";
    lua_package_cpath "/usr/local/openresty/lualib/?.so;;";

    client_body_temp_path /tmp/client_body_temp;
    proxy_temp_path /tmp/proxy_temp;
    fastcgi_temp_path /tmp/fastcgi_temp;
    uwsgi_temp_path /tmp/uwsgi_temp;
    scgi_temp_path /tmp/scgi_temp;
    # lua_temp_path /tmp/lua_temp; nginx: [emerg] unknown directive "lua_temp_path" in /app/nginx.conf.compiled:217
    lua_shared_dict sessions 10m;
    lua_shared_dict sessions_data 50m;
    lua_shared_dict ssl_certificates 1m;
    lua_shared_dict ssl_ocsp 1m;
    lua_shared_dict ssl_session 10m;
    lua_shared_dict rate_limit_store 10m;
    lua_shared_dict rate_limit_counters 10m;
    lua_shared_dict rate_limit_locks 1m;
    lua_shared_dict cache 50m;
    lua_shared_dict locks 1m;
    lua_shared_dict limit_req_store 10m;
    lua_shared_dict limit_req_counters 10m;
    lua_shared_dict limit_req_locks 1m;


    include mime.types;
    lua_shared_dict prometheus_metrics 50M;

    init_worker_by_lua_block {
        -- Initialize Prometheus metrics (requires lua_code_cache to be ON)
        local ok, metrics = pcall(require, "lib.prometheus_metrics")
        if ok then
        metrics.init()
        else
        ngx.log(ngx.WARN, "Prometheus metrics module not available: ", tostring(metrics))
        end
    }

    log_by_lua_block {
        local ok, metrics = pcall(require, "lib.prometheus_metrics")
        if not ok then return end
        
        local host = ngx.var.host:gsub("^www.", "")
        local status = tonumber(ngx.var.status)
        local method = ngx.var.request_method
        local uri = ngx.var.uri
        local remote_addr = ngx.var.remote_addr
        local request_time = ngx.now() - ngx.req.start_time()
        local request_length = tonumber(ngx.var.request_length) or 0
        local bytes_sent = tonumber(ngx.var.bytes_sent) or 0
        
        -- Extract endpoint (first 2 path segments for API grouping)
        local endpoint = uri:match("^(/[^/]*/[^/]*)")
        if not endpoint then
        endpoint = uri:match("^(/[^/]*)")
        end
        endpoint = endpoint or uri
        
        -- Basic HTTP metrics
        local metric_requests = metrics.get_metric_requests()
        local metric_latency = metrics.get_metric_latency()
        if metric_requests and metric_latency then
        metric_requests:inc(1, {host, tostring(status), method, endpoint})
        metric_latency:observe(request_time, {host, method, endpoint})
        end
        
        -- Request/Response size metrics
        local metric_request_size = metrics.get_metric_request_size()
        local metric_response_size = metrics.get_metric_response_size()
        if metric_request_size and metric_response_size then
        metric_request_size:observe(request_length, {host, method})
        metric_response_size:observe(bytes_sent, {host, method, tostring(status)})
        end
        
        -- Error tracking
        if status >= 400 then
        local metric_errors = metrics.get_metric_errors()
        if metric_errors then
            metric_errors:inc(1, {host, tostring(status), endpoint})
        end
        
        if status >= 400 and status < 500 then
            local metric_4xx = metrics.get_metric_4xx_errors()
            if metric_4xx then
            metric_4xx:inc(1, {host, tostring(status), endpoint})
            end
        elseif status >= 500 then
            local metric_5xx = metrics.get_metric_5xx_errors()
            if metric_5xx then
            metric_5xx:inc(1, {host, tostring(status), endpoint})
            end
        end
        end
        
        -- DDoS / Security: Track requests per IP
        local metric_requests_per_ip = metrics.get_metric_requests_per_ip()
        if metric_requests_per_ip then
        metric_requests_per_ip:inc(1, {remote_addr, host})
        end
        
        -- Detect suspicious patterns
        local metric_suspicious = metrics.get_metric_suspicious_requests()
        if metric_suspicious then
        local user_agent = ngx.var.http_user_agent or ""
        
        -- Suspicious patterns
        if user_agent == "" or user_agent == "-" then
            metric_suspicious:inc(1, {host, "no_user_agent"})
        end
        
        if uri:find("%.%.") or uri:find("//") then
            metric_suspicious:inc(1, {host, "path_traversal_attempt"})
        end
        
        if uri:lower():find("script") or uri:lower():find("exec") or uri:lower():find("union") then
            metric_suspicious:inc(1, {host, "injection_attempt"})
        end
        
        -- Rapid sequential errors from same IP
        if status == 404 or status == 403 then
            metric_suspicious:inc(1, {host, "error_" .. tostring(status)})
        end
        end
        
        -- Business metrics: Track API calls
        local metric_api_calls = metrics.get_metric_api_calls()
        if metric_api_calls and uri:match("^/api/") then
        metric_api_calls:inc(1, {endpoint, method, tostring(status)})
        end
        
        -- Track authentication attempts
        if uri:match("^/auth/") or uri:match("^/api/.*/login") then
        local metric_auth_attempts = metrics.get_metric_auth_attempts()
        if metric_auth_attempts then
            local result = (status == 200) and "success" or "failure"
            local auth_type = uri:match("/auth/([^/]+)") or "unknown"
            metric_auth_attempts:inc(1, {result, auth_type})
            
            if status ~= 200 then
            local metric_auth_failures = metrics.get_metric_auth_failures()
            if metric_auth_failures then
                local reason = (status == 401) and "invalid_credentials" or 
                            (status == 403) and "forbidden" or "other"
                metric_auth_failures:inc(1, {reason})
            end
            end
        end
        end
    }

    resolver 8.8.8.8 8.8.4.4 ipv6=off;

    server {
        listen ${{PORT}};
        lua_code_cache ${{CODE_CACHE}};

        # Simple location block - authentication is handled by Lapis
        location / {
            default_type text/html;
            
            content_by_lua_block {
                require("lapis").serve("app")
            }
        }

        location /static/ {
            alias static/;
        }

        location /favicon.ico {
            alias static/favicon.ico;
        }
        
        location /nginx_status {
            stub_status;
            allow 127.0.0.1;
            allow 10.0.0.0/8;
            allow 172.16.0.0/12;
            allow 192.168.0.0/16;
            allow 172.71.0.0/16;
            deny all;
          }

        location /metrics {
          allow 127.0.0.1;
          allow 10.0.0.0/8;
          allow 172.16.0.0/12;
          allow 192.168.0.0/16;
          allow 172.71.0.0/16;
          deny all;

          content_by_lua_block {
            local ok, metrics = pcall(require, "lib.prometheus_metrics")
            if ok then
              local metric_connections = metrics.get_metric_connections()
              local prometheus = metrics.get_prometheus()
              if metric_connections and prometheus then
                metric_connections:set(ngx.var.connections_reading, {"reading"})
                metric_connections:set(ngx.var.connections_waiting, {"waiting"})
                metric_connections:set(ngx.var.connections_writing, {"writing"})
                prometheus:collect()
              else
                ngx.status = 200
                ngx.header.content_type = "text/plain"
                ngx.say("# Prometheus metrics not available")
              end
            else
              ngx.log(ngx.ERR, "Failed to load metrics module: ", tostring(metrics))
              ngx.status = 200
              ngx.header.content_type = "text/plain"
              ngx.say("# Prometheus metrics not available")
            end
          }
        }

        location /500 {
            allow 127.0.0.1;
            allow 10.0.0.0/8;
            allow 172.16.0.0/12;
            allow 192.168.0.0/16;
            allow 172.71.0.0/16;
            deny all;
            return 500;
        }
        location /401 {
            return 401;
        }
        location /403 {
            return 403;
        }
        location /404 {
            return 404;
        }
        location /422 {
            return 422;
        }
        location /429 {
            return 429;
        }
        location /503 {
            return 503;
        }
        location /504 {
            return 504;
        }

    }
}