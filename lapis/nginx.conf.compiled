env LAPIS_ENVIRONMENT=development;
env KEYCLOAK_AUTH_URL;
env KEYCLOAK_TOKEN_URL;
env KEYCLOAK_USERINFO_URL;
env KEYCLOAK_CLIENT_ID;
env KEYCLOAK_CLIENT_SECRET;
env KEYCLOAK_REDIRECT_URI;
env DB_HOST;
env DB_USER;
env DB_PASSWORD;
env DATABASE;
env OPENSSL_SECRET_KEY;
env OPENSSL_SECRET_IV;
env JWT_SECRET_KEY;
env LAPIS_CONFIG;
env MINIO_ENDPOINT;
env MINIO_ACCESS_KEY;
env MINIO_SECRET_KEY;
env MINIO_BUCKET;
env MINIO_REGION;
env NODE_API_URL;
env GOOGLE_CLIENT_ID;
env GOOGLE_CLIENT_SECRET;
env GOOGLE_REDIRECT_URI;
env STRIPE_SECRET_KEY;
env STRIPE_PUBLISHABLE_KEY;
env STRIPE_WEBHOOK_SECRET;

env DNS_RESOLVER;
env REDIS_HOST;
env HOSTNAME;
env APP_NAME;
env LUA_DEBUG;
env VERSION;
env STACK;
env VITE_DEPLOYMENT_TIME;
env NGINX_CONFIG_DIR;
env JWT_SECURITY_PASSPHRASE;
env API_URL;
env PRIMARY_DNS_RESOLVER;
env SECONDARY_DNS_RESOLVER;
env DNS_RESOLVER_PORT;
env FRONT_URL;
env AWS_ACCESS_KEY_ID;
env AWS_SECRET_ACCESS_KEY;
env AWS_REGION;
env CORS_ORIGIN;

worker_processes 1;
error_log stderr notice;
daemon off;
pid logs/nginx.pid;

events {
  worker_connections 1024;
  multi_accept on;
  use epoll;}

http {

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for" "$host" "$request_id" $msec $request_time '
                    '$upstream_connect_time $upstream_header_time $upstream_response_time $ssl_protocol $ssl_cipher';

    access_log  /var/log/nginx/access.log  main;

    error_log  /var/log/nginx/error.log debug;

  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;
  keepalive_timeout 65;
  lua_package_path "/app/?.lua;/usr/local/openresty/lualib/?.lua;/opt/nginx-lua-prometheus/?.lua;/opt/nginx-lua-prometheus/lib/?.lua;/opt/lua-resty-jwt/lib/?.lua;/opt/lua-resty-session/lib/?.lua;;";
  lua_package_cpath "/usr/local/openresty/lualib/?.so;;";

  lua_shared_dict prometheus_metrics 50M;

  init_by_lua_block {
    require "lpeg"
    require "resty.session".init({
      remember = true,
      store_metadata = true,
      storage = "cookie",
      secret = "RaJKp8UQW1",
      cookie_name = "session",
    })
  }

  init_worker_by_lua_block {
    -- Initialize Prometheus metrics (requires lua_code_cache to be ON)
    local ok, metrics = pcall(require, "lib.prometheus_metrics")
    if ok then
      metrics.init()
    else
      ngx.log(ngx.WARN, "Prometheus metrics module not available: ", tostring(metrics))
    end
  }

  log_by_lua_block {
    local ok, metrics = pcall(require, "lib.prometheus_metrics")
    if not ok then return end
    
    local host = ngx.var.host:gsub("^www.", "")
    local status = tonumber(ngx.var.status)
    local method = ngx.var.request_method
    local uri = ngx.var.uri
    local remote_addr = ngx.var.remote_addr
    local request_time = ngx.now() - ngx.req.start_time()
    local request_length = tonumber(ngx.var.request_length) or 0
    local bytes_sent = tonumber(ngx.var.bytes_sent) or 0
    
    -- Extract endpoint (first 2 path segments for API grouping)
    local endpoint = uri:match("^(/[^/]*/[^/]*)")
    if not endpoint then
      endpoint = uri:match("^(/[^/]*)")
    end
    endpoint = endpoint or uri
    
    -- Basic HTTP metrics
    local metric_requests = metrics.get_metric_requests()
    local metric_latency = metrics.get_metric_latency()
    if metric_requests and metric_latency then
      metric_requests:inc(1, {host, tostring(status), method, endpoint})
      metric_latency:observe(request_time, {host, method, endpoint})
    end
    
    -- Request/Response size metrics
    local metric_request_size = metrics.get_metric_request_size()
    local metric_response_size = metrics.get_metric_response_size()
    if metric_request_size and metric_response_size then
      metric_request_size:observe(request_length, {host, method})
      metric_response_size:observe(bytes_sent, {host, method, tostring(status)})
    end
    
    -- Error tracking
    if status >= 400 then
      local metric_errors = metrics.get_metric_errors()
      if metric_errors then
        metric_errors:inc(1, {host, tostring(status), endpoint})
      end
      
      if status >= 400 and status < 500 then
        local metric_4xx = metrics.get_metric_4xx_errors()
        if metric_4xx then
          metric_4xx:inc(1, {host, tostring(status), endpoint})
        end
      elseif status >= 500 then
        local metric_5xx = metrics.get_metric_5xx_errors()
        if metric_5xx then
          metric_5xx:inc(1, {host, tostring(status), endpoint})
        end
      end
    end
    
    -- DDoS / Security: Track requests per IP
    local metric_requests_per_ip = metrics.get_metric_requests_per_ip()
    if metric_requests_per_ip then
      metric_requests_per_ip:inc(1, {remote_addr, host})
    end
    
    -- Detect suspicious patterns
    local metric_suspicious = metrics.get_metric_suspicious_requests()
    if metric_suspicious then
      local user_agent = ngx.var.http_user_agent or ""
      
      -- Suspicious patterns
      if user_agent == "" or user_agent == "-" then
        metric_suspicious:inc(1, {host, "no_user_agent"})
      end
      
      if uri:find("%.%.") or uri:find("//") then
        metric_suspicious:inc(1, {host, "path_traversal_attempt"})
      end
      
      if uri:lower():find("script") or uri:lower():find("exec") or uri:lower():find("union") then
        metric_suspicious:inc(1, {host, "injection_attempt"})
      end
      
      -- Rapid sequential errors from same IP
      if status == 404 or status == 403 then
        metric_suspicious:inc(1, {host, "error_" .. tostring(status)})
      end
    end
    
    -- Business metrics: Track API calls
    local metric_api_calls = metrics.get_metric_api_calls()
    if metric_api_calls and uri:match("^/api/") then
      metric_api_calls:inc(1, {endpoint, method, tostring(status)})
    end
    
    -- Track authentication attempts
    if uri:match("^/auth/") or uri:match("^/api/.*/login") then
      local metric_auth_attempts = metrics.get_metric_auth_attempts()
      if metric_auth_attempts then
        local result = (status == 200) and "success" or "failure"
        local auth_type = uri:match("/auth/([^/]+)") or "unknown"
        metric_auth_attempts:inc(1, {result, auth_type})
        
        if status ~= 200 then
          local metric_auth_failures = metrics.get_metric_auth_failures()
          if metric_auth_failures then
            local reason = (status == 401) and "invalid_credentials" or 
                          (status == 403) and "forbidden" or "other"
            metric_auth_failures:inc(1, {reason})
          end
        end
      end
    end
  }

  client_body_temp_path /tmp/client_body_temp;
  proxy_temp_path /tmp/proxy_temp;
  fastcgi_temp_path /tmp/fastcgi_temp;
  uwsgi_temp_path /tmp/uwsgi_temp;
  scgi_temp_path /tmp/scgi_temp;
  # lua_temp_path /tmp/lua_temp; nginx: [emerg] unknown directive "lua_temp_path" in /app/nginx.conf.compiled:217
  lua_shared_dict sessions 10m;
  lua_shared_dict sessions_data 50m;
  lua_shared_dict ssl_certificates 1m;
  lua_shared_dict ssl_ocsp 1m;
  lua_shared_dict ssl_session 10m;
  lua_shared_dict rate_limit_store 10m;
  lua_shared_dict rate_limit_counters 10m;
  lua_shared_dict rate_limit_locks 1m;
  lua_shared_dict cache 50m;
  lua_shared_dict locks 1m;
  lua_shared_dict limit_req_store 10m;
  lua_shared_dict limit_req_counters 10m;
  lua_shared_dict limit_req_locks 1m;

  resolver 127.0.0.11 ipv6=off;
  # for kubernetes use this resolver can also try kube-dns.kube-system.svc.cluster.local if you do not know the IP
  # resolver 10.43.0.10 ipv6=off;
  server {
    listen 8080;
    lua_code_cache on;

    location / {
      default_type text/octet-stream;

      # Professional CORS configuration with origin validation
      set $cors_origin "";

      # Allow localhost origins for development
      if ($http_origin ~* "^https?://localhost:([0-9]+)$") {
          set $cors_origin $http_origin;
      }
      if ($http_origin ~* "^https?://127\.0\.0\.1:([0-9]+)$") {
          set $cors_origin $http_origin;
      }

      # Allow kisaan.com and all subdomains for production
      if ($http_origin ~* "^https?://([a-zA-Z0-9\-]+\.)?googleapis\.com$") {
          set $cors_origin $http_origin;
      }

      # Set CORS headers only for allowed origins
      add_header 'Access-Control-Allow-Origin' $cors_origin always;
      add_header 'Access-Control-Allow-Credentials' 'true' always;
      add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, DELETE, PATCH' always;
      add_header 'Access-Control-Allow-Headers' 'Origin, Content-Type, Accept, Authorization, X-User-Email, X-Public-Browse, X-User-Id, X-Requested-With' always;
      add_header 'Access-Control-Max-Age' '86400' always;
      add_header 'Vary' 'Origin' always;

      # Handle preflight OPTIONS requests
      if ($request_method = 'OPTIONS') {
          add_header 'Access-Control-Allow-Origin' $cors_origin always;
          add_header 'Access-Control-Allow-Credentials' 'true' always;
          add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, DELETE, PATCH' always;
          add_header 'Access-Control-Allow-Headers' 'Origin, Content-Type, Accept, Authorization, X-User-Email, X-Public-Browse, X-User-Id, X-Requested-With' always;
          add_header 'Access-Control-Max-Age' '86400' always;
          add_header 'Vary' 'Origin' always;
          add_header 'Content-Length' '0' always;
          add_header 'Content-Type' 'text/plain' always;
          return 204;
      }

        access_by_lua_block {
        local uri = ngx.var.request_uri
        local method = ngx.req.get_method()
        local public_browse_header = ngx.var.http_x_public_browse

        -- Allow /auth/* routes without JWT
          if uri == "/" or uri == "/swagger/swagger.json" or uri:match("^/auth/") then
            return
          end
          if uri == "/api/v2/enquiries" and method == "POST" then return end
          if uri == "/api/v2/register" and method == "POST" then return end
          
          -- Allow public browsing of products and stores for GET requests
          if method == "GET" and public_browse_header == "true" then
            if uri:match("^/api/v2/storeproducts") or 
               uri:match("^/api/v2/stores/[^/]+/products") or
               uri:match("^/api/v2/products/[^/]+/variants") or
               uri:match("^/api/v2/stores") or
               uri:match("^/api/v2/products") or
               uri:match("^/api/v2/categories") then
              -- Set guest user for public browsing
              ngx.req.set_header("X-User-Id", "guest")
              return
            end
          end
          
          -- Cart operations now require authentication
          -- Remove guest cart access for security

        local jwt = require "resty.jwt"
        local cjson = require "cjson"

        local auth_header = ngx.var.http_authorization
        if not auth_header then
          ngx.status = ngx.HTTP_UNAUTHORIZED
          ngx.say(cjson.encode({ error = "Missing Authorization header" }))
          return ngx.exit(ngx.HTTP_UNAUTHORIZED)
        end

        local token = auth_header:match("Bearer%s+(.+)")
        if not token then
          ngx.status = ngx.HTTP_UNAUTHORIZED
          ngx.say(cjson.encode({ error = "Invalid Authorization format. Use Bearer <token>" }))
          return ngx.exit(ngx.HTTP_UNAUTHORIZED)
        end

        local secret = os.getenv("JWT_SECRET_KEY")
        local jwt_obj = jwt:verify(secret, token)

        if not jwt_obj.verified then
          ngx.status = ngx.HTTP_UNAUTHORIZED
          ngx.say(cjson.encode({ error = "Invalid token", reason = jwt_obj.reason }))
          return ngx.exit(ngx.HTTP_UNAUTHORIZED)
        end

        -- Forward user claims to Lapis
        local userinfo = jwt_obj.payload.userinfo or {}
        ngx.req.set_header("X-User-Id", userinfo.uuid or userinfo.id or "")
        ngx.req.set_header("X-User-Email", userinfo.email or "")
      }

      content_by_lua_block {
        require("lapis").serve("app")
      }

      # try_files $uri $uri/ =404;

    }

    location /static/ {
      alias static/;
    }

    location /favicon.ico {
      alias static/favicon.ico;
    }


    location /nginx_status {
        stub_status;
        allow 127.0.0.1;
        allow 10.0.0.0/8;
        allow 172.16.0.0/12;
        allow 192.168.0.0/16;
        allow 172.71.0.0/16;
        deny all;
      }


    location /metrics {
      allow 127.0.0.1;
      allow 10.0.0.0/8;
      allow 172.16.0.0/12;
      allow 192.168.0.0/16;
      allow 172.71.0.0/16;
      deny all;

      content_by_lua_block {
        local ok, metrics = pcall(require, "lib.prometheus_metrics")
        if ok then
          local metric_connections = metrics.get_metric_connections()
          local prometheus = metrics.get_prometheus()
          if metric_connections and prometheus then
            metric_connections:set(ngx.var.connections_reading, {"reading"})
            metric_connections:set(ngx.var.connections_waiting, {"waiting"})
            metric_connections:set(ngx.var.connections_writing, {"writing"})
            prometheus:collect()
          else
            ngx.status = 200
            ngx.header.content_type = "text/plain"
            ngx.say("# Prometheus metrics not available")
          end
        else
          ngx.log(ngx.ERR, "Failed to load metrics module: ", tostring(metrics))
          ngx.status = 200
          ngx.header.content_type = "text/plain"
          ngx.say("# Prometheus metrics not available")
        end
      }
    }

        location /500 {
          allow 127.0.0.1;
          allow 10.0.0.0/8;
          allow 172.16.0.0/12;
          allow 192.168.0.0/16;
          allow 172.71.0.0/16;
          deny all;
          return 500;
        }
      location /401 {
           return 401;
        }
      location /403 {
           return 403;
        }
      location /404 {
           return 404;
        }
      location /422 {
           return 422;
        }
      location /429 {
           return 429;
        }
      location /503 {
           return 503;
        }
      location /504 {
           return 504;
        }

    location /metrics_dev {
      stub_status;
      allow 127.0.0.1;
      allow 10.0.0.0/8;
      allow 172.16.0.0/12;
      allow 192.168.0.0/16;
      allow 172.71.0.0/16;
      deny all;

      content_by_lua_block {
        local metric_connections = package.loaded.metric_connections
        local prometheus = package.loaded.prometheus

        if metric_connections and prometheus then
          metric_connections:set(ngx.var.connections_reading, {"reading"})
          metric_connections:set(ngx.var.connections_waiting, {"waiting"})
          metric_connections:set(ngx.var.connections_writing, {"writing"})
          prometheus:collect()
        else
          ngx.log(ngx.ERR, "Prometheus metrics not initialized in metrics endpoint")
          ngx.status = 500
          ngx.say("Metrics not available")
        end
      }
    }
  }

  server {
    listen 8081;
    server_name _;
    location /api {
      proxy_pass http://172.71.0.12:8080/;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
    }

    location / {
      proxy_pass http://host.docker.internal:3000/;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
    }
  }

}